# JVM

## Java类加载过程

Java的类加载过程分为三个主要步骤：加载、链接、初始化

### 加载

加载阶段主要是将字节码数据从不同的数据源读到JVM中，并映射为JVM认可的数据结构（Class对象），这里的数据流可以是各种各样的形态，如jar文件、class文件、甚至是网络数据源等；如果输入的数据不是ClassFile的结构，则会抛出ClassFormatError。

加载阶段使用户可以参与的阶段，可以自定义类加载器，实现自己的加载过程

### 链接

这是最核心的步骤，简单的说是吧类定义信息转入JVM运行的过程，这里一共可以分为三步

- 验证，JVM需要核验字节信息是否服务Java虚拟机规范，否则被认为是VerifyError，这样可以防止恶意信息或者不符合规范的信息危害JVM的运行，验证阶段有可能触发更多的类加载
- 准备，创建类或者接口中的静态变量，并初始化静态变量的初始值（原始类型常量在这一步直接初始化完成），这里只要是分配空间，赋予初始值，不会去执行进一步的JVM指令
- 解析，将常量池中的符号引用替换为直接引用，类和接口、字段、类方法、接口方法等各个方面的解析
  
  ### 初始化
  
  这一步真正的去执行类初始化的代码逻辑，包括静态字段赋值，类中的静态代码块中的逻辑，父类型的初始化逻辑优先于当前类型的初始化

## 双亲委派模型

当类加载器试图加载一个类是，会先去让父类加载器加载该类，如果父类加载器可以加载则直接加载，无法加载，则再回到最初的子类加载器加载

## Jvm运行时内存区域

![Jvm运行时内存](https://picbed.howiewant.top/20230302214824.png)

### 程序计数器

程序计数器可以看作是当前线程所执行的字节码的行号指示器，Java在多线程切换时，为了能恢复到切换前执行的位置，每条线程都需要一个独立的程序计数器，所以程序计数器是线程私有的

### 虚拟机栈

虚拟机栈描述的是Java方法执行的线程内存模型；每个方法执行时Java虚拟机都会同步创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。虚拟机栈描述的是线程执行时的内存模型，因此虚拟机栈也是线程私有的

### 本地方法栈

与虚拟机栈类似，本地方法为java虚拟机执行本地方法服务

### 堆（heap）

Jvm中对象主要存储的位置，垃圾回收的重点区域

### 方法区（non-heap）

方法区是各个线程共享的区域，用户存储被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据

HotSpot虚拟机在JDK8之前使用的是永久代来实现方法区，主要是为了垃圾回收统一管理方方法区和堆内存，JDK7时已经把原本的字符串常量池和静态变量移出（堆），JDK8正式把永久代更换为元空间（MetaSpace），使用本地内存直接存储并将永久代剩余部分全部移到元空间中

运行时常量池，作为方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息，还有一项是常量池表，主要用于存放编译期间生成的各种字面量和符号引用，这部分内容将在类加载后存放到运行时常量池中

| 区域   | 参数                        | 描述                                  |
|:---- | ------------------------- | ----------------------------------- |
| 堆    | -Xms                      | 初始堆大小                               |
|      | -Xmx                      | 最大堆大小                               |
| 栈    | -Xss                      | 初始栈大小                               |
| 元空间  | -XX:MaxMetaspaceSize      | 元空间最大值，默认-1，不受限制                    |
|      | -XX:MetaspaceSize         | 元空间初始大小，到达该值会触发垃圾收集进行类型卸载，同时会调整该值大小 |
|      | -XX:MinMetaspaceFreeRatio | 垃圾收集之后最小的元空间剩余容量百分比                 |
|      | -XX:MaxMetaspaceFreeRatio | 垃圾收集之后最大的元空间剩余容量百分比                 |
| 直接内存 | -XX:MaxDirectMemorySize   | 默认与Xmx一致                            |

## 垃圾回收机制
### 哪些垃圾需要回收
- 引用计数算法，在对象中添加一个引用计数器，每当有一个地方引用对象时，引用计数器加一，当引用失效时引用计数器减一
- 可达性分析算法，在GC Root引用链上的对象被称为可到达的
![可达性分析](https://picbed.howiewant.top/20230306224057.png)
Java中固定的一些可以作为GC Root的对象  
  1. 虚拟机栈中引用的对象，比如各个线程被调用时方法堆栈中使用的参数，局部变量，临时变量等
  2. 方法区中静态属性引用的对象，比如Java类的引用类型静态变量
  3. 方法区中常量引用的对象，比如字符串常量池里的引用
  4. Native方法引用的对象
  5. Java虚拟机内部的引用，比如基本数据类型对应的class对象，常驻的异常对象，还有系统类加载器
  6. 所有同步锁持有的对象
### 引用
Java中的引用分为强引用，软引用，弱引用，虚引用
- 强引用，代码中直接的引用赋值
- 软引用，在系统内存溢出前会把这些对象列入二次回收的名单，再次回收后仍然没有足够的内存才会报出内存溢出异常
- 弱引用，垃圾回收发生即会被回收的对象，无论当前内存是否足够
- 虚引用，最弱的引用关系，无法通过虚引用获得该对象，该引用的唯一目的是在对象被回收时收到一个系统通知
### 方法区的回收
方法区的回收主要分为两个部分，废弃的常量和不再使用的类型
- 常量池中的常量没有地方引用时，且垃圾收集器判断确有必要回收，常量才会被回收
- 类型的回收条件较为苛刻，需要满足三种条件
  - 该类的所有实例均已被回收
  - 加载该类的类加载器被回收
  - 该类对应的类类型没有在任何地方被引用


